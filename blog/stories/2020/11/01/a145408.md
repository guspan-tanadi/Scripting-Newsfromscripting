<img src="http://scripting.com/images/2020/11/01/lizLemon.png" border="0" align="right">I finally understand what <a href="https://en.wikipedia.org/wiki/Agile_software_development">agile</a> means in programming, and of course, I've been doing it from the beginning of my programming career. Get something working, try it out, learn from it, perhaps go in a different direction, but always checking what I'm doing by using it and listening to users. <a href="https://en.wikipedia.org/wiki/Mitch_Kapor">Mitch Kapor</a>, who I learned a lot from at Personal Software in the early 80s, worked this way. I ran <a href="https://en.wikipedia.org/wiki/Living_Videotext">Living Videotext</a> on these principles. Everything <a href="https://en.wikipedia.org/wiki/UserLand_Software">UserLand</a> did was developed this way. Now that I understand what it means, I might try to factor all the writing that's out there about it into a few words that explain the difference. I once encountered <i>anti-agile</i> development in a company where the software was developed using <a href="https://dod.defense.gov/">DoD</a> procedures. Their philosophy was design the whole thing up front and give pieces of the project to different groups of programmers, who never saw the full spec, so no one knew what they were working on. The company went out of business very quickly. The team went on to form the core of another company, which also went out of business, each time because the product widely missed the mark.
